#ifndef TEMP_H
#define TEMP_H

#include "Catch2/Catch.hpp"

#include <cstdlib>
#include <math.h>

#define SAFE_BLOCKS

namespace Blocks
{

#define TRUE 1
#define FALSE 0
#define BOOL char
#define INT int

#ifdef SAFE_BLOCKS
#define CHECK_INDEX(block, index, indexName, functionName) \
    if(index > block->Capacity) \
    { \
        printf("[Block::" functionName "]: Invalid arguments; " indexName " exceeding block Capacity\n"); \
        printf("[Block::" functionName "]: " indexName ": %u\n", index); \
        printf("[Block::" functionName "]: block Capacity: %u\n", block->Capacity); \
        printf("[Block::" functionName "]: Further execution undefined\n"); \
    }
#else
#define CHECK_INDEX(block, index, indexName, functionName)
#endif


    //Base
    struct Block
    {
            char * Data;
            unsigned int Size;
            unsigned int Capacity;
    };
    struct ConstBlock
    {
            const char * Data;
            unsigned int Size;
            unsigned int Capacity;
    };
    
    //OPTIONAL
    inline void * GetData(Block* block)      {return block->Data;}
    inline unsigned int GetSize(Block* block)      {return block->Size;}
    inline unsigned int GetCapacity(Block* block)  {return block->Capacity;}

    //NECESARRY
    
    Block CreateEmptyBlock()
    {
        Block block;
        block.Data = NULL;
        block.Capacity = 0;
        block.Size = 0;

        return block;
    }

    inline BOOL IsCharIndexValid(Block* block, unsigned int charSize)
    {
        return charSize <= block.Capacity;
    }

    inline BOOL IsIntIndexValid(Block* block, unsigned int intSize)
    {
        return IsCharIndexValid(block, intSize*sizeof(int));
    }

    inline void SetCharSize(Block* block, unsigned int newCharSize)
    {
        CHECK_INDEX(block, newCharSize, "newCharSize", "SetCharSize");
        block->Size = newCharSize;
    }

    inline void SetIntSize(Block* block, unsigned int newIntSize)
    {
        SetCharSize(block, newIntSize*sizeof(int));
    }

    Block CreateCharBlock(char * data, unsigned int charSize, unsigned int charCapacity)
    {
        Block block;
        block.Data = data;
        block.Capacity = charCapacity;
        block.Size = charSize;
        CHECK_INDEX((&block), charSize, "charSize", "CreateCharBlock");

        return block;
    }
    
    ConstBlock CreateConstCharBlock(const char * data, unsigned int charSize, unsigned int charCapacity)
    {
        ConstBlock block;
        block.Data = data;
        block.Capacity = charCapacity;
        block.Size = charSize;
        CHECK_INDEX((&block), charSize, "charSize", "CreateCharBlock");

        return block;
    }
    
    inline ConstBlock ToConstBlock(Block * block)
    {
        return CreateConstCharBlock(block->Data, block->Size, block->Capacity);
    }

    inline Block CreateIntBlock(INT * data, unsigned int intSize, unsigned int intCapacity)
    {
        return CreateCharBlock((char*)(void*)data, intSize*sizeof(int), intCapacity*sizeof(int));
    }

    inline char* CharAt(Block* block, unsigned int charIndex)
    {
        CHECK_INDEX(block, charIndex, "charindex", "CharAt");
        return block->Data + charIndex;
    }

    inline int* IntAt(Block* block, unsigned int charIndex)
    {
        return (int*)(void*)CharAt(block, charIndex*sizeof(int));
    }
    
    //Get Set
    inline char GetCharAt(Block* block, unsigned int charIndex)
    {
        return *CharAt(block, charIndex);
    }

    inline int GetIntAt(Block* block, unsigned int intIndex)
    {
        return *IntAt(block, intIndex);
    }
    
    inline void SetCharAt(Block* block, unsigned int charIndex, char to)
    {
        *CharAt(block, charIndex) = to;
    }

    inline void SetIntAt(Block* block, unsigned int intIndex, INT to)
    {
        *IntAt(block, intIndex) = to;
    }

    //Allocating
    inline Block AllocateCharBlock(unsigned int charCapacity)
    {
        return CreateCharBlock((char*)malloc(charCapacity*sizeof(char)), 0, charCapacity);
    }

    inline Block AllocateIntBlock(unsigned int intCapacity)
    {
        return AllocateCharBlock(intCapacity*sizeof(int));
    }

    #define LOG_2 0.69314718055995
    double LogBase(double x, double base)
    {
        return log(x) / log(base);
    }
    
    double LogBase2(double x)
    {
        return log(x) / LOG_2;
    }
        
    void ReallocateCharBlock(Block* block, unsigned int newCharCapacity)
    {
        realloc(block->Data, newCharCapacity);
        block->Capacity = newCharCapacity;
    }
    
    inline void ReallocateIntBlock(Block* block, unsigned int newIntCapacity)
    {
        ReallocateCharBlock(block, newIntCapacity*sizeof(int));
    }
    
    BOOL GrowCharBlockToFit(Block* block, unsigned int toFitChars)
    {
        if(block->Capacity > toFitChars)
            return FALSE;
        
        if(block->Capacity == 0)
        {
            ReallocateCharBlock(block, toFitChars);
            return TRUE;
        }
        
        const double log2 = LogBase2((double)toFitChars / (double)block->Capacity);
        const double ceiled = ceil(log2);
        const unsigned int finalMultiply = pow(2, ceiled);
        ReallocateCharBlock(block, block->Capacity*finalMultiply);
        return TRUE;
    }
    
    inline BOOL GrowIntBlockToFit(Block* block, unsigned int toFitInts)
    {
        return GrowCharBlockToFit(block, toFitInts*sizeof(int));
    }
    
    inline void FreeBlock(Block* block)
    {
        free(block->Data);
    }

    //Copying
    #define MAX( a, b ) ( ( a > b) ? a : b )
    #define MIN( a, b ) ( ( a < b) ? a : b )
    
    //Copy block and return if all data was copied
    BOOL CopyCharBlockTo(Block* to, Block* from, unsigned int charIndex)
    {
        CHECK_INDEX(to, charIndex, "charIndex", "CopyCharBlockTo");
        if(IsCharIndexValid(to, charIndex))
            return FALSE;
        
        const unsigned int copyToSize = to->Capacity - charIndex;
        const unsigned int copyFromSize = from->Size;
        
        unsigned int copySize = MIN(copyToSize, copyFromSize);
        BOOL returnStatus;
        
        if(copyToSize < copyFromSize)
        {
            //Is not able to copy the whole data - is limited 
            // by the to->Capacity
            copySize = copyToSize;
            returnStatus = FALSE;
        }
        else
        {
            copySize = copyFromSize;
            returnStatus = TRUE;
        }
        
        memcpy(to->Data + charIndex, from->Data, copySize);
        to->Size = copySize + charIndex;
        return returnStatus;
    }
   
    inline BOOL CopyIntBlockTo(Block* to, Block* from, unsigned int intIndex)
    {
        return CopyCharBlockTo(to, from, intIndex*sizeof(int));
    }
    
    inline BOOL CopyBlock(Block* to, Block* from)
    {
        return CopyCharBlockTo(to, from, 0);
    }
    
    inline BOOL AppendBlock(Block* to, Block* from)
    {
        return CopyCharBlockTo(to, from, to->Size);
    }

    //Strings
    #define STRING_TERMINATOR '\0'
    inline void TerminateStringBlock(Block* block)
    {
        *CharAt(block, block->Size) = STRING_TERMINATOR;
    }
    
    Block CreateStringBlock(char * data, unsigned int charSize, unsigned int charCapacity)
    {
        Block block;
        block.Data = data;
        block.Capacity = charCapacity - 1;
        block.Size = charSize;
        if(charSize + 1 > charCapacity) 
        { 
            printf("[Block::" "CreateStringBlock" "]: Invalid arguments; charSize must be at least 1 less than block Capacity\n"); 
            printf("[Block::" "CreateStringBlock" "]: charSize: %u\n", charSize); 
            printf("[Block::" "CreateStringBlock" "]: block Capacity: %u\n", charCapacity); 
            printf("[Block::" "CreateStringBlock" "]: Further execution undefined\n"); 
        }
        
        TerminateStringBlock(&block);
        block.Data[block.Capacity] = STRING_TERMINATOR;
        return block;
    }
    
    inline ConstBlock ToConstStringBlock(const char * str)
    {
        const unsigned int len = strlen(str);
        return CreateConstCharBlock(str, len, len+1);
    }
    
    BOOL CopyStringBlockTo(Block* to, Block* from, unsigned int intIndex)
    {
        BOOL state = CopyCharBlockTo(to, from, intIndex*sizeof(int));
        TerminateStringBlock(to);
        return state;
    }
    
    inline BOOL CopyStringBlock(Block* to, Block* from)
    {
        return CopyStringBlockTo(to, from, 0);
    }
    
    inline BOOL AppendStringBlock(Block* to, Block* from)
    {
        return CopyStringBlockTo(to, from, to->Size);
    }

    
}

namespace cio::Testing
{

    TEST_CASE("Testing of everything", "[Everything]")
    {
    }
}

#endif // TEMP_H
